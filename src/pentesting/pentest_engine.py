"""
Penetration Testing Engine

Full-stack offensive security management:
- Web, Mobile, Cloud & API penetration testing
- Secure architecture & threat modeling
- Red teaming & social engineering
- Finding tracking and remediation
"""

from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional
from datetime import datetime
import logging
import uuid

logger = logging.getLogger(__name__)

PENTEST_TYPES = {
    'web_app': {'name': 'Web Application', 'icon': 'bi-globe', 'methodology': 'OWASP Testing Guide v4.2'},
    'mobile': {'name': 'Mobile Application', 'icon': 'bi-phone', 'methodology': 'OWASP MASTG'},
    'cloud': {'name': 'Cloud Infrastructure', 'icon': 'bi-cloud', 'methodology': 'CIS Benchmarks + Custom'},
    'api': {'name': 'API Security', 'icon': 'bi-braces', 'methodology': 'OWASP API Security Top 10'},
    'network': {'name': 'Network/Infrastructure', 'icon': 'bi-hdd-network', 'methodology': 'PTES + OSSTMM'},
    'red_team': {'name': 'Red Team Exercise', 'icon': 'bi-bullseye', 'methodology': 'TIBER-EU / CBEST'},
    'social_eng': {'name': 'Social Engineering', 'icon': 'bi-person-badge', 'methodology': 'Custom SE Framework'},
}

SEVERITY_WEIGHTS = {'Critical': 10, 'High': 7, 'Medium': 4, 'Low': 1, 'Informational': 0}

OWASP_TOP_10 = [
    'A01 - Broken Access Control', 'A02 - Cryptographic Failures',
    'A03 - Injection', 'A04 - Insecure Design',
    'A05 - Security Misconfiguration', 'A06 - Vulnerable Components',
    'A07 - Authentication Failures', 'A08 - Software & Data Integrity',
    'A09 - Logging & Monitoring Failures', 'A10 - SSRF',
]


@dataclass
class Finding:
    id: str
    title: str
    severity: str
    category: str
    description: str
    impact: str
    remediation: str
    status: str = 'open'
    cvss_score: Optional[float] = None
    affected_component: str = ''
    evidence: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'id': self.id, 'title': self.title, 'severity': self.severity,
            'category': self.category, 'description': self.description,
            'impact': self.impact, 'remediation': self.remediation,
            'status': self.status, 'cvss_score': self.cvss_score,
            'affected_component': self.affected_component,
            'evidence': self.evidence, 'references': self.references,
        }


@dataclass
class PentestEngagement:
    id: str
    name: str
    pentest_type: str
    methodology: str
    scope: List[str]
    status: str  # planned, in_progress, completed, remediation
    start_date: str
    end_date: Optional[str]
    findings: List[Finding]
    risk_score: float
    executive_summary: str = ''

    def to_dict(self) -> Dict[str, Any]:
        severity_counts = {}
        for f in self.findings:
            severity_counts[f.severity] = severity_counts.get(f.severity, 0) + 1
        return {
            'id': self.id, 'name': self.name, 'pentest_type': self.pentest_type,
            'methodology': self.methodology, 'scope': self.scope,
            'status': self.status, 'start_date': self.start_date, 'end_date': self.end_date,
            'finding_count': len(self.findings), 'severity_counts': severity_counts,
            'risk_score': round(self.risk_score, 1),
            'executive_summary': self.executive_summary,
            'findings': [f.to_dict() for f in self.findings],
        }


@dataclass
class ThreatModel:
    application: str
    threats: List[Dict[str, Any]]
    attack_surface: List[Dict[str, Any]]
    mitigations: List[Dict[str, Any]]
    risk_rating: str

    def to_dict(self) -> Dict[str, Any]:
        return {
            'application': self.application, 'threats': self.threats,
            'attack_surface': self.attack_surface,
            'mitigations': self.mitigations, 'risk_rating': self.risk_rating,
        }


@dataclass
class PentestResult:
    analysis_id: str
    completed_at: datetime
    engagements: List[PentestEngagement]
    overall_risk_score: float
    grade: str
    coverage: Dict[str, Any]
    remediation_tracker: Dict[str, Any]
    recommendations: List[Dict[str, Any]]

    def to_dict(self) -> Dict[str, Any]:
        return {
            'analysis_id': self.analysis_id,
            'completed_at': self.completed_at.isoformat(),
            'engagements': [e.to_dict() for e in self.engagements],
            'overall_risk_score': round(self.overall_risk_score, 1),
            'grade': self.grade, 'coverage': self.coverage,
            'remediation_tracker': self.remediation_tracker,
            'recommendations': self.recommendations,
        }


class PentestEngine:
    """Full-stack penetration testing management engine"""

    def analyze(self, data: Dict[str, Any]) -> PentestResult:
        """Run complete pentest analysis"""
        logger.info("Starting pentest analysis")

        engagements = self._build_engagements(data)
        risk_score = self._calculate_risk_score(engagements)
        grade = self._score_to_grade(100 - risk_score)
        coverage = self._assess_coverage(data)
        remediation = self._build_remediation_tracker(engagements)
        recommendations = self._generate_recommendations(engagements, coverage)

        return PentestResult(
            analysis_id=str(uuid.uuid4()), completed_at=datetime.utcnow(),
            engagements=engagements, overall_risk_score=risk_score,
            grade=grade, coverage=coverage,
            remediation_tracker=remediation, recommendations=recommendations,
        )

    def create_engagement(self, name: str, pentest_type: str,
                          scope: List[str]) -> PentestEngagement:
        """Create a new pentest engagement"""
        pt = PENTEST_TYPES.get(pentest_type, PENTEST_TYPES['web_app'])
        return PentestEngagement(
            id=str(uuid.uuid4()), name=name, pentest_type=pentest_type,
            methodology=pt['methodology'], scope=scope,
            status='planned', start_date=datetime.utcnow().strftime('%Y-%m-%d'),
            end_date=None, findings=[], risk_score=0,
        )

    def threat_model(self, application: str, components: List[str]) -> ThreatModel:
        """Generate threat model using STRIDE methodology"""
        stride = ['Spoofing', 'Tampering', 'Repudiation', 'Information Disclosure', 'Denial of Service', 'Elevation of Privilege']
        threats = []
        for component in components:
            for threat_type in stride:
                threats.append({
                    'component': component, 'threat_type': threat_type,
                    'description': f'{threat_type} threat against {component}',
                    'likelihood': 'medium', 'impact': 'high',
                    'risk': 'medium',
                })

        attack_surface = [{'component': c, 'entry_points': ['Network', 'API', 'User Interface'], 'exposure': 'external'} for c in components]
        mitigations = [{'threat_type': t, 'mitigation': f'Implement controls against {t}', 'status': 'planned'} for t in stride]

        return ThreatModel(
            application=application, threats=threats,
            attack_surface=attack_surface, mitigations=mitigations,
            risk_rating='medium',
        )

    def _build_engagements(self, data: Dict[str, Any]) -> List[PentestEngagement]:
        """Build engagement list from data"""
        engagements = data.get('engagements', [])
        results = []
        for eng in engagements:
            findings = [Finding(
                id=str(uuid.uuid4()), title=f.get('title', ''),
                severity=f.get('severity', 'Medium'), category=f.get('category', 'General'),
                description=f.get('description', ''), impact=f.get('impact', ''),
                remediation=f.get('remediation', ''), status=f.get('status', 'open'),
                cvss_score=f.get('cvss_score'), affected_component=f.get('component', ''),
            ) for f in eng.get('findings', [])]

            risk = sum(SEVERITY_WEIGHTS.get(f.severity, 0) for f in findings)
            max_risk = len(findings) * 10 if findings else 1
            risk_pct = (risk / max_risk * 100) if max_risk > 0 else 0

            results.append(PentestEngagement(
                id=eng.get('id', str(uuid.uuid4())), name=eng.get('name', 'Unnamed'),
                pentest_type=eng.get('type', 'web_app'),
                methodology=PENTEST_TYPES.get(eng.get('type', 'web_app'), {}).get('methodology', 'Custom'),
                scope=eng.get('scope', []), status=eng.get('status', 'completed'),
                start_date=eng.get('start_date', ''), end_date=eng.get('end_date'),
                findings=findings, risk_score=risk_pct,
            ))
        return results

    def _calculate_risk_score(self, engagements: List[PentestEngagement]) -> float:
        if not engagements:
            return 0
        return sum(e.risk_score for e in engagements) / len(engagements)

    def _assess_coverage(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Assess pentest coverage across attack surface"""
        covered = data.get('covered_areas', [])
        all_areas = list(PENTEST_TYPES.keys())
        return {
            'total_areas': len(all_areas),
            'covered': len([a for a in all_areas if a in covered]),
            'coverage_pct': round(len([a for a in all_areas if a in covered]) / len(all_areas) * 100, 1),
            'uncovered': [PENTEST_TYPES[a]['name'] for a in all_areas if a not in covered],
            'areas': {a: {'name': PENTEST_TYPES[a]['name'], 'covered': a in covered} for a in all_areas},
        }

    def _build_remediation_tracker(self, engagements: List[PentestEngagement]) -> Dict[str, Any]:
        all_findings = [f for e in engagements for f in e.findings]
        open_count = sum(1 for f in all_findings if f.status == 'open')
        in_progress = sum(1 for f in all_findings if f.status == 'in_progress')
        resolved = sum(1 for f in all_findings if f.status in ('resolved', 'closed'))
        return {
            'total_findings': len(all_findings), 'open': open_count,
            'in_progress': in_progress, 'resolved': resolved,
            'resolution_rate': round(resolved / len(all_findings) * 100, 1) if all_findings else 100,
            'by_severity': {s: sum(1 for f in all_findings if f.severity == s and f.status == 'open') for s in SEVERITY_WEIGHTS},
        }

    def _generate_recommendations(self, engagements: List[PentestEngagement], coverage: Dict) -> List[Dict]:
        recs = []
        if coverage.get('coverage_pct', 0) < 70:
            recs.append({'title': 'Expand Pentest Coverage', 'description': f'Only {coverage["coverage_pct"]}% coverage. Test: {", ".join(coverage.get("uncovered", [])[:3])}', 'priority': 'high'})

        for eng in engagements:
            critical = [f for f in eng.findings if f.severity == 'Critical' and f.status == 'open']
            if critical:
                recs.append({'title': f'Remediate Critical Findings - {eng.name}', 'description': f'{len(critical)} critical findings still open', 'priority': 'critical'})

        recs.append({'title': 'Schedule Regular Testing', 'description': 'Conduct pentests at least annually or after major changes', 'priority': 'medium'})
        return recs

    def _score_to_grade(self, score: float) -> str:
        if score >= 90: return 'A+'
        if score >= 80: return 'A'
        if score >= 70: return 'B+'
        if score >= 60: return 'B'
        if score >= 50: return 'C'
        if score >= 40: return 'D'
        return 'F'
