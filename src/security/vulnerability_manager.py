"""Vulnerability Management Engine"""
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from enum import Enum
from datetime import datetime, timedelta


class VulnerabilitySeverity(Enum):
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFORMATIONAL = "Informational"


class VulnerabilityStatus(Enum):
    OPEN = "Open"
    IN_PROGRESS = "In Progress"
    REMEDIATED = "Remediated"
    ACCEPTED = "Risk Accepted"
    FALSE_POSITIVE = "False Positive"


@dataclass
class Vulnerability:
    vuln_id: str
    title: str
    severity: VulnerabilitySeverity
    cvss_score: float
    affected_asset: str
    description: str = ""
    cve_id: str = ""
    status: VulnerabilityStatus = VulnerabilityStatus.OPEN
    discovered_date: datetime = field(default_factory=datetime.utcnow)
    due_date: datetime = None
    remediation_notes: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "vuln_id": self.vuln_id,
            "title": self.title,
            "severity": self.severity.value,
            "cvss_score": self.cvss_score,
            "affected_asset": self.affected_asset,
            "description": self.description,
            "cve_id": self.cve_id,
            "status": self.status.value,
            "discovered_date": self.discovered_date.isoformat() if self.discovered_date else None,
            "due_date": self.due_date.isoformat() if self.due_date else None
        }


@dataclass
class VulnerabilityReport:
    entity_id: str
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    open_count: int
    remediated_count: int
    overdue_count: int
    avg_remediation_time: float  # days
    risk_score: float
    trend: str
    priority_remediations: List[str]
    statistics: Dict[str, Any]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "entity_id": self.entity_id,
            "total_vulnerabilities": self.total_vulnerabilities,
            "critical_count": self.critical_count,
            "high_count": self.high_count,
            "medium_count": self.medium_count,
            "low_count": self.low_count,
            "open_count": self.open_count,
            "remediated_count": self.remediated_count,
            "overdue_count": self.overdue_count,
            "avg_remediation_time": round(self.avg_remediation_time, 1),
            "risk_score": round(self.risk_score, 1),
            "trend": self.trend,
            "priority_remediations": self.priority_remediations,
            "statistics": self.statistics
        }


class VulnerabilityManager:
    """Vulnerability management and tracking engine."""

    # SLA days by severity
    REMEDIATION_SLA = {
        VulnerabilitySeverity.CRITICAL: 7,
        VulnerabilitySeverity.HIGH: 30,
        VulnerabilitySeverity.MEDIUM: 90,
        VulnerabilitySeverity.LOW: 180,
        VulnerabilitySeverity.INFORMATIONAL: 365
    }

    SEVERITY_WEIGHTS = {
        VulnerabilitySeverity.CRITICAL: 10,
        VulnerabilitySeverity.HIGH: 7,
        VulnerabilitySeverity.MEDIUM: 4,
        VulnerabilitySeverity.LOW: 1,
        VulnerabilitySeverity.INFORMATIONAL: 0.1
    }

    def __init__(self, custom_slas: Optional[Dict[VulnerabilitySeverity, int]] = None):
        self.slas = custom_slas or self.REMEDIATION_SLA

    def calculate_due_date(self, vuln: Vulnerability) -> datetime:
        """Calculate due date based on severity SLA."""
        sla_days = self.slas.get(vuln.severity, 90)
        return vuln.discovered_date + timedelta(days=sla_days)

    def is_overdue(self, vuln: Vulnerability) -> bool:
        """Check if vulnerability is overdue."""
        if vuln.status in [VulnerabilityStatus.REMEDIATED, VulnerabilityStatus.FALSE_POSITIVE]:
            return False
        due = vuln.due_date or self.calculate_due_date(vuln)
        return datetime.utcnow() > due

    def calculate_risk_score(self, vulnerabilities: List[Vulnerability]) -> float:
        """Calculate overall vulnerability risk score (0-100)."""
        if not vulnerabilities:
            return 0

        open_vulns = [v for v in vulnerabilities if v.status == VulnerabilityStatus.OPEN]
        if not open_vulns:
            return 0

        total_weight = sum(
            self.SEVERITY_WEIGHTS.get(v.severity, 1) * (1.5 if self.is_overdue(v) else 1)
            for v in open_vulns
        )

        # Normalize to 0-100 (assuming max 100 critical vulns = 100 score)
        max_weight = 100 * self.SEVERITY_WEIGHTS[VulnerabilitySeverity.CRITICAL]
        return min(100, (total_weight / max_weight) * 100)

    def generate_report(self, vulnerabilities: List[Vulnerability],
                        entity_id: str = "unknown",
                        previous_count: int = None) -> VulnerabilityReport:
        """Generate comprehensive vulnerability report."""
        # Count by severity
        critical = sum(1 for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL)
        high = sum(1 for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH)
        medium = sum(1 for v in vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM)
        low = sum(1 for v in vulnerabilities if v.severity == VulnerabilitySeverity.LOW)

        # Count by status
        open_count = sum(1 for v in vulnerabilities if v.status == VulnerabilityStatus.OPEN)
        remediated = sum(1 for v in vulnerabilities if v.status == VulnerabilityStatus.REMEDIATED)
        overdue = sum(1 for v in vulnerabilities if self.is_overdue(v))

        # Calculate average remediation time (mock calculation)
        avg_time = 15.0  # Default

        # Calculate risk score
        risk_score = self.calculate_risk_score(vulnerabilities)

        # Determine trend
        if previous_count is not None:
            if open_count < previous_count * 0.9:
                trend = "Improving"
            elif open_count > previous_count * 1.1:
                trend = "Deteriorating"
            else:
                trend = "Stable"
        else:
            trend = "Baseline"

        # Priority remediations
        sorted_vulns = sorted(
            [v for v in vulnerabilities if v.status == VulnerabilityStatus.OPEN],
            key=lambda x: (
                0 if x.severity == VulnerabilitySeverity.CRITICAL else
                1 if x.severity == VulnerabilitySeverity.HIGH else 2,
                self.is_overdue(x)
            ),
            reverse=True
        )
        priority = [f"{v.title} ({v.severity.value}) - {v.affected_asset}" for v in sorted_vulns[:5]]

        # Statistics
        stats = {
            "by_severity": {"critical": critical, "high": high, "medium": medium, "low": low},
            "by_status": {"open": open_count, "remediated": remediated, "overdue": overdue},
            "sla_compliance": round((1 - overdue / max(open_count, 1)) * 100, 1) if open_count > 0 else 100
        }

        return VulnerabilityReport(
            entity_id=entity_id,
            total_vulnerabilities=len(vulnerabilities),
            critical_count=critical,
            high_count=high,
            medium_count=medium,
            low_count=low,
            open_count=open_count,
            remediated_count=remediated,
            overdue_count=overdue,
            avg_remediation_time=avg_time,
            risk_score=risk_score,
            trend=trend,
            priority_remediations=priority,
            statistics=stats
        )
